<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes" />
  <title>DXB Gate Picker</title>

    <style>
    @font-face{
      font-family:"LocalFont";
      src: url("font.ttf") format("truetype");
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body{
      margin:0;
      min-height:100vh;
      background:#1f9d55;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
      display:flex; align-items:center; justify-content:center;
      color:#fff;
    }

        #screenLoad, #viewer{
      font-family:"LocalFont",sans-serif;
    }
    #screenLoad button, #screenLoad input, #screenLoad select,
    #viewer button, #viewer input, #viewer select{
      font-family:"LocalFont",sans-serif;
    }

    .screen{ width:100%; display:none; }
    .screen.active{ display:block; }

    .container{
      width:100%;
      max-width:420px;
      padding:32px 24px 40px;
      text-align:center;
      margin:0 auto;
    }

    h1{ font-size:28px; margin:0 0 40px; font-weight:800; letter-spacing:.5px; }

    .result{
      font-size:92px; font-weight:400; line-height:1; letter-spacing:1px;
      display:inline-block; text-shadow:0 10px 28px rgba(0,0,0,.25);
    }

    @keyframes pop{
      0%{transform:translateY(18px) scale(.8);opacity:0}
      55%{transform:translateY(-10px) scale(1.25);opacity:1}
      80%{transform:translateY(4px) scale(.96)}
      100%{transform:translateY(0) scale(1)}
    }
    .pop{ animation:pop 460ms cubic-bezier(.2,.9,.2,1) both; }

    .btn{
      width:100%;
      border:none;
      border-radius:18px;
      background:#fff;
      cursor:pointer;
      box-shadow:0 7px 0 #148243;
      display:flex; align-items:center; justify-content:center;
      transition:transform .06s ease, box-shadow .06s ease, background-color .12s ease;
      -webkit-tap-highlight-color:transparent;
      position:relative; overflow:hidden;
    }
    .btn:active{
      transform:translateY(5px);
      box-shadow:0 2px 0 #148243;
      background-color:#e5e7eb;
    }
    .btn.pressed::after{ content:""; position:absolute; inset:0; background:rgba(0,0,0,.08); }

    #pickBtn{ margin-top:52px; height:88px; }
    #pickBtn svg{ width:46px; height:46px; stroke:#1f9d55; stroke-width:2.2; fill:none; }

    #mapBtn, #loadBtn{
      margin-top:14px; height:62px; font-size:16px; font-weight:800;
      color:#1f9d55; letter-spacing:.2px;
    }
    #mapBtn svg, #loadBtn svg{
      width:20px; height:20px; margin-right:10px; stroke:#1f9d55; stroke-width:2.2; fill:none;
    }

    /* ---------- Fullscreen viewer (Maps) ---------- */
    .viewer{
      position:fixed; inset:0; background:#000; display:none; z-index:999;
      touch-action: pinch-zoom;
    }
    .viewer.show{ display:block; }

    .viewerHeader{
      position:absolute; top:0; left:0; right:0;
      padding:14px 14px 10px;
      display:flex; align-items:center; justify-content:space-between;
      z-index:3;
      background:linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,0));
    }
    .badge{
      font-size:13px; font-weight:700; color:rgba(255,255,255,.9);
      background:rgba(255,255,255,.14);
      border:1px solid rgba(255,255,255,.18);
      padding:8px 10px; border-radius:999px;
      backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
      user-select:none;
    }
    .closeX{
      border:none; background:rgba(255,255,255,.14);
      border:1px solid rgba(255,255,255,.18);
      border-radius:14px;
      width:44px; height:44px;
      display:grid; place-items:center;
      cursor:pointer;
      backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
      -webkit-tap-highlight-color:transparent;
    }
    .closeX svg{ width:22px; height:22px; stroke:#fff; stroke-width:2.4; fill:none; }

    .track{
      height:100%; width:100%;
      display:flex;
      transform:translateX(0);
      transition:transform 240ms ease;
      will-change:transform;
      touch-action: pan-y pinch-zoom;
    }
    .slide{
      min-width:100%;
      height:100%;
      display:grid;
      place-items:center;
      padding:64px 10px 18px;
      user-select:none;
    }
    .slide img{
      max-width:100%;
      max-height:calc(100vh - 90px);
      object-fit:contain;
      display:block;
      -webkit-user-drag:none;
      user-select:none;
      pointer-events:auto;
      touch-action: pinch-zoom;
    }
    .dots{
      position:absolute; left:0; right:0; bottom:14px;
      display:flex; justify-content:center; gap:8px;
      z-index:3; pointer-events:none;
    }
    .dot{ width:7px; height:7px; border-radius:999px; background:rgba(255,255,255,.35); }
    .dot.active{ background:rgba(255,255,255,.92); }

    /* ---------- Load Screen (Full-bleed White) ---------- */
    #screenLoad{
      position:fixed;
      inset:0;
      background:#ffffff;
      color:#000;
      z-index:20;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      overscroll-behavior: contain;
    }
    #screenLoad .container{
      color:#000;
      max-width:420px;
      margin:0 auto;
      padding:24px 18px 40px;
      text-align:center;
    }

    .loadHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin:0 0 16px;
    }
    .leftControls{
      display:flex;
      align-items:center;
      gap:10px;
      flex:1;
      min-width:0;
    }

    .homeBtn, .iconBtn{
      width:44px; height:44px;
      border:none;
      border-radius:14px;
      background:#ffffff;
      border:1px solid rgba(0,0,0,0.16);
      display:grid; place-items:center;
      cursor:pointer;
      -webkit-tap-highlight-color:transparent;
      box-shadow: 0 6px 16px rgba(0,0,0,0.08);
      flex:0 0 auto;
    }
    .homeBtn:active, .iconBtn:active{ transform: scale(0.98); }
    .homeBtn svg, .iconBtn svg{
      width:22px; height:22px;
      stroke:#111; stroke-width:2.4; fill:none;
      opacity:0.95;
    }

    .loadTitle{
      font-size:24px;
      font-weight:900;
      letter-spacing:.2px;
      margin:0;
      text-align:left;
      flex:1;
      min-width:0;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      color:#000;
    }

    .panel{
      width:100%;
      background:#ffffff;
      border: 1px solid rgba(0,0,0,0.12);
      border-radius: 18px;
      padding: 14px;
      text-align:left;
      box-shadow: 0 10px 26px rgba(0,0,0,0.08);
    }

    .label{
      font-size:12px;
      font-weight:800;
      letter-spacing:0.5px;
      opacity:0.9;
      margin:0 0 8px;
      text-transform: uppercase;
      color:#111;
    }

    .selectWrap{ position:relative; }
    .chev{
      position:absolute;
      right:12px;
      top:50%;
      transform:translateY(-50%);
      width:18px; height:18px;
      stroke:rgba(0,0,0,0.72);
      stroke-width:2.6;
      fill:none;
      pointer-events:none;
      opacity:0.95;
    }

    select{
      width:100%;
      height:48px;
      border-radius:14px;
      border:1px solid rgba(0,0,0,0.16);
      background:#fff;
      color:#000;
      font-size:15px;
      padding: 0 44px 0 12px;
      outline:none;
      appearance:none;
      -webkit-appearance:none;
    }

    /* ??Light Load toggle row */
    .toggleRow{
      margin-top:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(0,0,0,0.12);
      background: rgba(0,0,0,0.02);
    }
    .toggleRow .tLabel{
      font-size:14px;
      font-weight:800;
      color:#111;
      letter-spacing:.2px;
    }
    .toggleRow input[type="checkbox"]{
      width:22px; height:22px;
      accent-color:#1f9d55;
    }

    /* ??Class ??Load Í∞ÑÍ≤© Ï§ÑÏù¥Í∏?+ Î°úÎìú ?´Ïûê??Í∞ôÏ? ??*/
    .table{
      margin-top: 14px;
      width:100%;
      border-collapse: collapse;
      overflow:hidden;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,0.12);
      table-layout: fixed;
      color:#000;
    }

    .table th, .table td{
      padding: 8px 6px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      font-size: 15px;
    }

    .table th{
      text-align:left;
      font-weight:900;
      background: rgba(0,0,0,0.04);
      color:#000;
    }

        .table th:first-child, .table td:first-child{
      width: 60%;
      padding-right: 6px;
    }
        .table th:last-child, .table td:last-child{
      width: 40%;
      text-align:right;
      font-variant-numeric: tabular-nums;
      padding-left: 6px;
      color: inherit;
    }
    .table tr:last-child td{ border-bottom:none; }

    .clsCell{ font-weight:900; white-space: nowrap; }

    .rowF{ color:#8b0000; }
    .rowC{ color:#0b2a6f; }
    .rowW{ color:#6b21a8; }
    .rowY{ color:#0f7a2a; }

    .totalRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-top: 12px;
      padding: 12px 10px;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(0,0,0,0.04);
      font-size: 15px;
      font-variant-numeric: tabular-nums;
      color:#000;
    }
        .totalLeft{ font-weight:900; letter-spacing:0.2px; }
    .totalRight{ text-align:right; white-space:nowrap; }
    .seatmapHeader{
      margin-top:16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .seatmapBtn{
      height:32px;
      border-radius:10px;
      border:1px solid rgba(0,0,0,0.16);
      background:#ffffff;
      color:#111;
      font-size:12px;
      font-weight:800;
      padding:0 10px;
      cursor:pointer;
      box-shadow: 0 6px 16px rgba(0,0,0,0.08);
      -webkit-tap-highlight-color:transparent;
    }
    .seatmapBtn:active{ transform: scale(0.98); }
    .seatmapMeta{
      margin:6px 0 10px;
      font-size:12px;
      color:#444;
    }
    .seatmapWrap{
      width:100%;
      background: #f7f7f7;
      border: 1px solid rgba(0,0,0,0.12);
      border-radius: 14px;
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .seatmapRow{
      width:100%;
      display:grid;
      grid-template-columns: repeat(var(--row-cols), minmax(0, 1fr));
      column-gap: var(--row-gap-x, 4px);
      row-gap: var(--row-gap-y, 4px);
      padding: 0 var(--row-pad-x, 0px);
      align-items:stretch;
    }
    .seatmapRow.gapRow{ height:14px; }
    .seatmapRow.exitRow{ position:relative; }
    .seatmapRow.exitRow::before,
    .seatmapRow.exitRow::after{
      content:"EXIT";
      position:absolute;
      top:50%;
      transform:translateY(-50%);
      font-size:10px;
      font-weight:900;
      letter-spacing:0.4px;
      color:#c1121f;
      background:#ffffff;
      border:1px solid #c1121f;
      border-radius:999px;
      padding:2px 6px;
      line-height:1;
      white-space:nowrap;
      pointer-events:none;
    }
    .seatmapRow.exitRow::before{ left:2px; }
    .seatmapRow.exitRow::after{ right:2px; }
    .seatCell{
      width:100%;
      aspect-ratio:1 / 1;
      border-radius:4px;
      position:relative;
      overflow:visible;
    }
    .seatCell.space{ background:transparent; }
    .seatCell.seat::before{
      content:"";
      position:absolute;
      inset: var(--seat-inset, 0px);
      border-radius:4px;
      background: var(--seat-color);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.18);
      transform: scale(var(--seat-scale, 1));
      transform-origin:center;
    }
    .seatCell.occupied::before{ background:#9ca3af; }
    .seatCell[data-class="F"]{ --seat-color:#8b0000; --seat-scale:1; --seat-inset:4px; }
    .seatCell[data-class="C"]{ --seat-color:#0b2a6f; --seat-scale:1.08; }
    .seatCell[data-class="W"]{ --seat-color:#6b21a8; --seat-scale:1.0; }
    .seatCell[data-class="Y"]{ --seat-color:#0f7a2a; }

    @media (prefers-reduced-motion: reduce){
      .track{ transition:none; }
      .pop{ animation:none; }
    }
  </style>
</head>

<body>

  <!-- ================= MAIN SCREEN ================= -->
  <div id="screenMain" class="screen active">
    <div class="container">
      <h1>DXB Gate Picker</h1>

      <div class="result" id="result">--</div>

      <button id="pickBtn" class="btn" type="button" aria-label="Generate Gate">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M21 12a9 9 0 1 1-2.64-6.36"/>
          <polyline points="21 3 21 9 15 9"/>
        </svg>
      </button>

      <button id="mapBtn" class="btn" type="button" aria-label="View Map">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 6l6-2 6 2 6-2v14l-6 2-6-2-6 2V6z"/>
          <path d="M9 4v14M15 6v14"/>
        </svg>
        View Map
      </button>

      <button id="loadBtn" class="btn" type="button" aria-label="Load">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M7 13V6a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v7"/>
          <path d="M5 13h14v3a3 3 0 0 1-3 3H8a3 3 0 0 1-3-3v-3z"/>
          <path d="M6 19v2M18 19v2"/>
        </svg>
        Load
      </button>
    </div>
  </div>

  <!-- ================= LOAD SCREEN ================= -->
  <div id="screenLoad" class="screen" aria-hidden="true">
    <div class="container">
      <div class="loadHeader">
        <div class="leftControls">
          <button id="homeBtn" class="homeBtn" type="button" aria-label="Back to Home">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M10 19l-7-7 7-7"/>
              <path d="M3 12h18"/>
            </svg>
          </button>
          <h2 class="loadTitle">Load</h2>
        </div>

        <button id="loadRefreshBtn" class="iconBtn" type="button" aria-label="Refresh Load">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M21 12a9 9 0 1 1-2.64-6.36"/>
            <polyline points="21 3 21 9 15 9"/>
          </svg>
        </button>
      </div>

      <div class="panel">
        <div class="label">Aircraft</div>

        <div class="selectWrap">
          <select id="aircraftSelect" aria-label="Select Aircraft"></select>
          <svg class="chev" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M6 9l6 6 6-6"/>
          </svg>
        </div>

        <!-- ??Light Load checkbox -->
        <div class="toggleRow" role="group" aria-label="Light Load toggle">
          <div class="tLabel">Light Load</div>
          <input id="lightLoadChk" type="checkbox" />
        </div>

        <table class="table" id="loadTable" aria-label="Load table">
          <thead>
            <tr>
              <th>Class</th>
              <th>Load</th>
            </tr>
          </thead>
          <tbody id="loadTbody"></tbody>
        </table>

        <div class="totalRow" aria-label="Total load">
          <div class="totalLeft">Total</div>
          <div class="totalRight" id="totalText">0 / 0 (0.0%)</div>
        </div>
<div class="seatmapHeader">
          <div class="label">Seatmap</div>
        </div>
        <div class="seatmapMeta" id="seatmapMeta">Seatmap not loaded</div>
        <div class="seatmapWrap" id="seatmapWrap" aria-label="Seatmap"></div>
        <input id="seatmapFile" type="file" accept=".xlsx" hidden />
      </div>
    </div>
  </div>

  <!-- ================= MAP VIEWER ================= -->
  <div id="viewer" class="viewer" role="dialog" aria-modal="true" aria-label="Maps">
    <div class="viewerHeader">
      <div id="badge" class="badge">1 / 2</div>
      <button id="closeViewer" class="closeX" type="button" aria-label="Close">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 6l12 12M18 6L6 18"/>
        </svg>
      </button>
    </div>

    <div id="track" class="track">
      <div class="slide"><img src="h1.png" alt="h1 map" draggable="false" /></div>
      <div class="slide"><img src="h2.png" alt="h2 map" draggable="false" /></div>
    </div>

    <div class="dots" aria-hidden="true">
      <div class="dot" id="dot0"></div>
      <div class="dot" id="dot1"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    const addPressFeedback = (btn) => {
      const on = () => btn.classList.add('pressed');
      const off = () => btn.classList.remove('pressed');
      btn.addEventListener('pointerdown', on);
      btn.addEventListener('pointerup', off);
      btn.addEventListener('pointerleave', off);
      btn.addEventListener('pointercancel', off);
    };

    const screenMain = document.getElementById('screenMain');
    const screenLoad = document.getElementById('screenLoad');

    const showScreen = (name) => {
      const isMain = name === 'main';
      screenMain.classList.toggle('active', isMain);
      screenLoad.classList.toggle('active', !isMain);
      screenLoad.setAttribute('aria-hidden', String(isMain));
      document.body.style.background = isMain ? '#1f9d55' : '#ffffff';
      if (!isMain) screenLoad.scrollTop = 0;
    };

    /* ---------- Gate logic ---------- */
    const range = (p, s, e, ex = new Set()) => {
      const a = [];
      for (let i = s; i <= e; i++) {
        const v = `${p}${i}`;
        if (!ex.has(v)) a.push(v);
      }
      return a;
    };

    const poolA = range("A", 1, 24, new Set(["A6","A7","A18","A19"]));
    const poolB = range("B", 6, 32, new Set(["B7","B16"]));
    const poolC = range("C", 1, 23, new Set(["C15"]));
    const pools = { A: poolA, B: poolB, C: poolC, Remote: ["Remote"] };

    const pickCategory = () => {
      const r = Math.random() * 100;
      if (r < 30) return "A";
      if (r < 60) return "B";
      if (r < 90) return "C";
      return "Remote";
    };
    const pickOne = (a) => a[Math.floor(Math.random() * a.length)];
    const haptic = () => { if (navigator.vibrate) navigator.vibrate([20,12,20]); };

    const resultEl = document.getElementById('result');
    const pickBtn = document.getElementById('pickBtn');
    const mapBtn  = document.getElementById('mapBtn');
    const loadBtn = document.getElementById('loadBtn');

    addPressFeedback(pickBtn);
    addPressFeedback(mapBtn);
    addPressFeedback(loadBtn);

    const playPop = () => {
      resultEl.classList.remove('pop');
      void resultEl.offsetWidth;
      resultEl.classList.add('pop');
    };

    pickBtn.addEventListener('click', () => {
      haptic();
      resultEl.textContent = pickOne(pools[pickCategory()]);
      playPop();
    });

    /* ---------- Maps viewer + swipe ---------- */
    const viewer = document.getElementById('viewer');
    const closeViewer = document.getElementById('closeViewer');
    const track = document.getElementById('track');
    const badge = document.getElementById('badge');
    const dots = [document.getElementById('dot0'), document.getElementById('dot1')];

    const slideCount = 2;
    let mapIndex = 0;

    const setMapIndex = (i, animate = true) => {
      mapIndex = Math.max(0, Math.min(slideCount - 1, i));
      track.style.transition = animate ? 'transform 240ms ease' : 'none';
      track.style.transform = `translateX(${-mapIndex * 100}%)`;
      badge.textContent = `${mapIndex + 1} / ${slideCount}`;
      dots.forEach((d, idx) => d.classList.toggle('active', idx === mapIndex));
    };

    const openViewer = () => {
      viewer.classList.add('show');
      document.body.style.overflow = 'hidden';
      setMapIndex(0, false);
    };
    const closeViewerFn = () => {
      viewer.classList.remove('show');
      document.body.style.overflow = '';
    };

    mapBtn.addEventListener('click', openViewer);
    closeViewer.addEventListener('click', closeViewerFn);

    const activePointers = new Map();
    let startX = 0, dx = 0, swiping = false;
    const vw = () => Math.max(1, window.innerWidth || 375);

    track.addEventListener('pointerdown', (e) => {
      if (!viewer.classList.contains('show')) return;
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (activePointers.size === 1) {
        swiping = true; startX = e.clientX; dx = 0;
        track.style.transition = 'none';
      } else {
        swiping = false;
      }
      track.setPointerCapture(e.pointerId);
    });

    track.addEventListener('pointermove', (e) => {
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (!swiping || activePointers.size !== 1) return;
      dx = e.clientX - startX;
      const base = -mapIndex * vw();
      track.style.transform = `translateX(${base + dx}px)`;
    });

    const endSwipe = () => {
      if (!swiping) return;
      swiping = false;
      const threshold = Math.min(90, vw() * 0.22);
      if (dx > threshold) setMapIndex(mapIndex - 1, true);
      else if (dx < -threshold) setMapIndex(mapIndex + 1, true);
      else setMapIndex(mapIndex, true);
      dx = 0;
    };

    const onPointerUpOrCancel = (e) => {
      if (activePointers.has(e.pointerId)) activePointers.delete(e.pointerId);
      if (activePointers.size === 0) endSwipe();
      if (activePointers.size === 1) swiping = false;
    };

    track.addEventListener('pointerup', onPointerUpOrCancel);
    track.addEventListener('pointercancel', onPointerUpOrCancel);
    setMapIndex(0, false);

    /* ---------- Load screen logic ---------- */
    const aircraftSelect = document.getElementById('aircraftSelect');
    const lightLoadChk = document.getElementById('lightLoadChk');
    const loadTbody = document.getElementById('loadTbody');
    const loadRefreshBtn = document.getElementById('loadRefreshBtn');
    const homeBtn = document.getElementById('homeBtn');
    const totalText = document.getElementById('totalText');    const seatmapFile = document.getElementById('seatmapFile');
    const seatmapMeta = document.getElementById('seatmapMeta');
    const seatmapWrap = document.getElementById('seatmapWrap');

    let currentLoads = {};
    let currentAircraftName = "";
    let currentSeatmapKey = "";
    let seatmapByKey = {};
    let seatmapGroups = {};

    const aircraftData = [
      { name: "A350 Mid Range", classes: { C: 32, W: 21, Y: 259 } },
      { name: "A350 Ultra Long Range", classes: { C: 32, W: 21, Y: 238 } },
      { name: "A380 Two Class", classes: { C: 58, Y: 557 } },
      { name: "A380 Three Class Mid Range", classes: { F: 14, C: 76, Y: [427, 429] } },
      { name: "A380 Three Class Ultra Long Range", classes: { F: 14, C: 76, Y: [399, 401] } },
      { name: "A380 Four Class", classes: { F: 14, C: 76, W: 56, Y: [322, 338, 341] } },
      { name: "B777-200LR", classes: { C: 38, Y: 264 } },
      { name: "B777-300ER Two Class", classes: { C: 35, Y: 386 } },
      { name: "B777-300ER Three Class", classes: { F: 8, C: 42, Y: [304, 310] } },
      { name: "B777-300ER Four Class", classes: { F: 8, C: 40, W: 24, Y: [256, 260] } },
      { name: "B777-300ER Four Class Game Changer", classes: { F: 6, C: 38, W: 24, Y: 256 } }
    ];
    const classOrder = ["F","C","W","Y"];
    const classLabels = {
      F: "First Class",
      C: "Business Class",
      W: "Premium Economy",
      Y: "Economy Class"
    };
    const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const pickCap = (v) => Array.isArray(v) ? v[randInt(0, v.length - 1)] : v;

    // Í∏∞Î≥∏ ?âÍ∑† ?ëÏäπÎ•?Mean)
    const BASE_MEAN = { F: 0.50, C: 0.70, W: 0.60, Y: 0.80 };
    // 100% ?ïÎ•†(Í∑∏Î?Î°??†Ï?)
    const FULL_CHANCE = { C: 0.10, Y: 0.15 };

    // ??Light Load Ï≤¥ÌÅ¨ ???âÍ∑†Í∞íÏùÑ 20%p ??∂§
    const LIGHT_DELTA = 0.20;

    const CONCENTRATION = 10;

    const randn = () => {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    };

    const gammaSample = (shape) => {
      if (shape < 1) return gammaSample(shape + 1) * Math.pow(Math.random(), 1 / shape);
      const d = shape - 1/3;
      const c = 1 / Math.sqrt(9 * d);
      while (true) {
        let x = randn();
        let v = 1 + c * x;
        if (v <= 0) continue;
        v = v * v * v;
        const u = Math.random();
        if (u < 1 - 0.0331 * (x * x) * (x * x)) return d * v;
        if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) return d * v;
      }
    };

    const betaSample = (a, b) => {
      const x = gammaSample(a);
      const y = gammaSample(b);
      return x / (x + y);
    };

    const clamp01 = (x) => Math.min(0.999, Math.max(0.001, x));

    const sampleLoadWithFullChance = (cap, targetMean, pFull) => {
      const p = Math.max(0, Math.min(1, pFull || 0));
      if (cap > 0 && Math.random() < p) return cap;

      const t = clamp01(targetMean);
      const denom = (1 - p);
      let mBase = denom <= 0 ? 0.999 : (t - p) / denom;
      mBase = clamp01(Math.max(0, mBase));

      const a = mBase * CONCENTRATION;
      const b = (1 - mBase) * CONCENTRATION;

      const frac = betaSample(a, b);
      const seats = Math.round(frac * cap);
      return Math.max(0, Math.min(cap, seats));
    };

    const fmtPct = (x) => `${(Math.round(x * 10) / 10).toFixed(1)}%`;

    const getTargetMean = (cls) => {
      const base = BASE_MEAN[cls] ?? 0.7;
      if (!lightLoadChk.checked) return base;
      return Math.max(0.01, base - LIGHT_DELTA); // ??20%p ??∂§
    };

    const pickSeatmapVariant = (aircraft) => {
      const variants = seatmapGroups[aircraft.name];
      if (!variants || variants.length === 0) return null;
      let targetY = null;
      const yVal = aircraft.classes?.Y;
      if (Array.isArray(yVal)) targetY = pickCap(yVal);
      else if (typeof yVal === "number") targetY = yVal;
      let variant = null;
      if (targetY !== null) {
        variant = variants.find((v) => v.yTagNumber === targetY)
          || variants.find((v) => v.counts.Y === targetY);
      }
      if (!variant) {
        variant = variants[Math.floor(Math.random() * variants.length)];
      }
      return { variant, targetY };
    };

    const renderLoad = () => {
      const idx = aircraftSelect.selectedIndex;
      const aircraft = aircraftData[Math.max(0, idx)];
      if (!aircraft) return;

      const caps = {};
      const selection = pickSeatmapVariant(aircraft);
      if (selection && selection.variant) {
        const seatmap = selection.variant;
        for (const k of Object.keys(seatmap.counts)) {
          const cap = seatmap.counts[k];
          if (cap > 0) caps[k] = cap;
        }
        currentSeatmapKey = seatmap.key;
      } else {
        for (const k of Object.keys(aircraft.classes)) caps[k] = pickCap(aircraft.classes[k]);
        currentSeatmapKey = aircraft.name;
      }

      const loads = {};
      for (const k of Object.keys(caps)) {
        const mean = getTargetMean(k);
        const pFull = FULL_CHANCE[k] ?? 0;
        loads[k] = sampleLoadWithFullChance(caps[k], mean, pFull);
      }

      loadTbody.innerHTML = "";
      for (const cls of classOrder) {
        if (!(cls in caps)) continue;

        const tr = document.createElement("tr");
        if (cls === "F") tr.classList.add("rowF");
        if (cls === "C") tr.classList.add("rowC");
        if (cls === "W") tr.classList.add("rowW");
        if (cls === "Y") tr.classList.add("rowY");

        const td1 = document.createElement("td");
        const td2 = document.createElement("td");

        td1.classList.add("clsCell");
        td1.textContent = classLabels[cls] || cls;
        td2.textContent = `${loads[cls]} / ${caps[cls]}`;

        tr.appendChild(td1);
        tr.appendChild(td2);
        loadTbody.appendChild(tr);
      }

      const totalLoad = Object.keys(loads).reduce((s,k)=>s+loads[k], 0);
      const totalCap  = Object.keys(caps).reduce((s,k)=>s+caps[k], 0);
      const occ = totalCap > 0 ? (totalLoad / totalCap) : 0;
      totalText.textContent = `${totalLoad} / ${totalCap} (${fmtPct(occ * 100)})`;      currentLoads = loads;
      currentAircraftName = aircraft.name;
      renderSeatmap();
    };

    const shuffle = (arr) => {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    };

    const formatCounts = (counts) => {
      const order = ["F","C","W","Y"];
      const parts = [];
      for (const cls of order) {
        if (counts[cls]) parts.push(`${cls}${counts[cls]}`);
      }
      return parts.join(" ");
    };
        const normalizeClass = (v) => {
      if (!v) return "";
      const t = String(v).trim().toUpperCase();
      return ["F","C","W","Y"].includes(t) ? t : "";
    };

    const parseSeatmapSheet = (sheet) => {
      if (!sheet || !sheet["!ref"]) return null;
      const range = XLSX.utils.decode_range(sheet["!ref"]);
      const counts = { F: 0, C: 0, W: 0, Y: 0 };
      const width = range.e.c - range.s.c + 1;
      const rowsRaw = [];
      const classRanges = {
        F: { start: Infinity, end: -Infinity },
        C: { start: Infinity, end: -Infinity },
        W: { start: Infinity, end: -Infinity }
      };
      const yBlocks = [];
      let currentY = null;

      for (let r = range.s.r; r <= range.e.r; r++) {
        const rowCells = new Array(width).fill("");
        const metaCell = sheet[XLSX.utils.encode_cell({ r, c: range.s.c })];
        const metaVal = metaCell ? String(metaCell.v).trim() : "";
        const isExit = /exit/i.test(metaVal);
        let firstCol = -1;
        let lastCol = -1;
        let rowClass = "";
        for (let c = range.s.c; c <= range.e.c; c++) {
          const cell = sheet[XLSX.utils.encode_cell({ r, c })];
          const cls = normalizeClass(cell ? cell.v : "");
          const idx = c - range.s.c;
          rowCells[idx] = cls;
          if (cls) {
            counts[cls] = (counts[cls] || 0) + 1;
            if (rowClass === "") rowClass = cls;
            if (firstCol === -1) firstCol = idx;
            lastCol = idx;
          }
        }

        const hasSeat = firstCol !== -1;
        const row = {
          cellsFull: rowCells,
          firstCol,
          lastCol,
          className: rowClass,
          hasSeat,
          yBlock: -1,
          exit: isExit
        };
        rowsRaw.push(row);

        if (hasSeat && rowClass && classRanges[rowClass]) {
          const rangeRef = classRanges[rowClass];
          rangeRef.start = Math.min(rangeRef.start, firstCol);
          rangeRef.end = Math.max(rangeRef.end, lastCol);
        }

        if (hasSeat && rowClass === "Y") {
          if (!currentY || currentY.lastRow !== r - 1) {
            currentY = { start: firstCol, end: lastCol, lastRow: r };
            yBlocks.push(currentY);
          } else {
            currentY.start = Math.min(currentY.start, firstCol);
            currentY.end = Math.max(currentY.end, lastCol);
            currentY.lastRow = r;
          }
          row.yBlock = yBlocks.length - 1;
        } else {
          currentY = null;
        }
      }
      let firstSeatRow = rowsRaw.findIndex((row) => row.hasSeat);
      let lastSeatRow = rowsRaw.length - 1;
      while (lastSeatRow >= 0 && !rowsRaw[lastSeatRow].hasSeat) lastSeatRow -= 1;

      if (firstSeatRow === -1) {
        rowsRaw.length = 0;
      } else {
        // Keep boundary EXIT marker rows that sit just outside the first/last seat rows.
        // Many seatmaps encode EXIT as a standalone (no-seat) row right before/after the seating block.
        let firstKeep = firstSeatRow;
        while (firstKeep > 0 && !rowsRaw[firstKeep - 1].hasSeat && rowsRaw[firstKeep - 1].exit) {
          firstKeep -= 1;
        }

        let lastKeep = lastSeatRow;
        while (lastKeep < rowsRaw.length - 1 && !rowsRaw[lastKeep + 1].hasSeat && rowsRaw[lastKeep + 1].exit) {
          lastKeep += 1;
        }

        rowsRaw.splice(0, firstKeep);
        rowsRaw.length = Math.max(0, lastKeep - firstKeep + 1);
      }
      const normalizedRows = rowsRaw.map((row) => {
        if (!row.hasSeat || !row.className) return { cells: [], cols: 0, hasSeat: false, exit: row.exit };
        let start = row.firstCol;
        let end = row.lastCol;
        if (row.className === "Y" && row.yBlock >= 0) {
          const block = yBlocks[row.yBlock];
          start = block.start;
          end = block.end;
        } else if (classRanges[row.className]) {
          const rangeRef = classRanges[row.className];
          if (rangeRef.end >= rangeRef.start) {
            start = rangeRef.start;
            end = rangeRef.end;
          }
        }
        const sliced = row.cellsFull.slice(start, end + 1);
        return { cells: sliced, cols: sliced.length, hasSeat: true, offset: start, exit: row.exit };
      });

      const maxCols = normalizedRows.reduce((m, row) => Math.max(m, row.cols), 0);
      return { rows: normalizedRows, maxCols, counts, baseCol: range.s.c };
    };

    const parseSheetInfo = (sheetName) => {
      const match = sheetName.match(/^(.*?)(?:\s*)?(Y\d+)$/i);
      let baseRaw = sheetName.trim();
      let yTag = "";
      let yTagNumber = null;
      if (match) {
        baseRaw = match[1].trim();
        yTag = match[2].toUpperCase();
        const num = parseInt(yTag.replace("Y", ""), 10);
        if (!Number.isNaN(num)) yTagNumber = num;
      }
      let baseName = baseRaw;
      const matched = aircraftData.find((a) => a.name.toLowerCase().startsWith(baseRaw.toLowerCase()));
      if (matched) baseName = matched.name;
      const displayName = yTag ? `${baseName} (${yTag})` : baseName;
      return { baseName, displayName, yTag, yTagNumber };
    };

    const ensureUniqueName = (name, used) => {
      if (!used.has(name)) {
        used.add(name);
        return name;
      }
      let idx = 2;
      let next = `${name} ${idx}`;
      while (used.has(next)) {
        idx += 1;
        next = `${name} ${idx}`;
      }
      used.add(next);
      return next;
    };

    const ensureAircraftBase = (baseName, seatmap) => {
      if (aircraftData.some((a) => a.name === baseName)) return;
      const classes = {};
      for (const cls of Object.keys(seatmap.counts)) {
        if (seatmap.counts[cls]) classes[cls] = seatmap.counts[cls];
      }
      aircraftData.push({ name: baseName, classes });
    };

    const parseSeatmapWorkbook = (wb) => {
      seatmapByKey = {};
      seatmapGroups = {};
      for (let i = aircraftData.length - 1; i >= 0; i--) {
        if (/\(Y\d+\)$/.test(aircraftData[i].name)) aircraftData.splice(i, 1);
      }
      const usedNames = new Set();
      for (const sheetName of wb.SheetNames) {
        const seatmap = parseSeatmapSheet(wb.Sheets[sheetName]);
        if (!seatmap) continue;
        const info = parseSheetInfo(sheetName);
        if (info.yTagNumber && seatmap.counts.Y) {
          seatmap.counts.Y = info.yTagNumber;
        }
        const displayName = ensureUniqueName(info.displayName, usedNames);
        const key = displayName;
        seatmapByKey[key] = seatmap;
        if (!seatmapGroups[info.baseName]) seatmapGroups[info.baseName] = [];
        seatmapGroups[info.baseName].push({
          key,
          displayName,
          yTag: info.yTag,
          yTagNumber: info.yTagNumber,
          counts: seatmap.counts
        });
        ensureAircraftBase(info.baseName, seatmap);
      }
      for (const [baseName, variants] of Object.entries(seatmapGroups)) {
        const yVals = Array.from(new Set(
          variants
            .map((v) => v.yTagNumber ?? v.counts.Y)
            .filter((v) => Number.isFinite(v))
        )).sort((a, b) => a - b);
        if (yVals.length > 0) {
          const idx = aircraftData.findIndex((a) => a.name === baseName);
          if (idx >= 0) {
            aircraftData[idx].classes = {
              ...aircraftData[idx].classes,
              Y: yVals.length > 1 ? yVals : yVals[0]
            };
          }
        }
      }
      const count = Object.keys(seatmapByKey).length;
      if (count === 0) {
        seatmapMeta.textContent = "Seatmap not loaded";
        renderSeatmap();
        return;
      }
      seatmapMeta.textContent = `Loaded ${count} sheet(s)`;
      initAircraftSelect(currentAircraftName || aircraftSelect.value);
    };

    const PREF_PROB = 0.8;
    const BASE_GAP_X = 4;
    const BASE_GAP_Y = 2;
    const C_EF_SHARE = 0.5;
    const C121_LOW_LOAD = 0.45;
    const C121_EF_SHARE = 0.3;
    const C121_WINDOW_SHARE = 0.7;
    const W_FRONT_SHARE = 0.7;
    const W_FRONT_SLICE = 0.45;
    const LOW_DENSITY_SCATTER = 0.6;
const ADJACENT_PAIR_SHARE = 0.2;
    const B777_C_GAP_X = 10;
    const B777_C_GAP_Y = 4;

    const pickFromList = (list, used) => {
      while (list.length) {
        const seat = list.pop();
        if (!used.has(seat.key)) return seat;
      }
      return null;
    };

    const pickFromSide = (leftList, rightList, biasSide, biasShare, used) => {
      const primary = biasSide == "L" ? leftList : rightList;
      const secondary = biasSide == "L" ? rightList : leftList;
      if (Math.random() < biasShare) {
        return pickFromList(primary, used) || pickFromList(secondary, used);
      }
      return pickFromList(secondary, used) || pickFromList(primary, used);
    };

    const buildRowOrder = (rowKeys) => {
      if (rowKeys.length <= 1) return rowKeys.slice();
      const sorted = rowKeys.slice().sort((a, b) => a - b);
      if (sorted.length <= 2) {
        shuffle(sorted);
        return sorted;
      }
      const bucketCount = Math.min(3, sorted.length);
      const bucketSize = Math.ceil(sorted.length / bucketCount);
      const buckets = [];
      for (let i = 0; i < bucketCount; i++) {
        const start = i * bucketSize;
        const end = Math.min(sorted.length, start + bucketSize);
        const bucket = sorted.slice(start, end);
        shuffle(bucket);
        buckets.push(bucket);
      }
      const rowOrder = [];
      while (rowOrder.length < sorted.length) {
        const active = [];
        for (let i = 0; i < buckets.length; i++) {
          if (buckets[i].length) active.push(i);
        }
        shuffle(active);
        for (const idx of active) {
          const bucket = buckets[idx];
          if (bucket.length) rowOrder.push(bucket.pop());
        }
      }
      return rowOrder;
    };

    const buildZigzagOrder = (seats) => {
      const byRow = new Map();
      for (const seat of seats) {
        if (!byRow.has(seat.row)) byRow.set(seat.row, []);
        byRow.get(seat.row).push(seat);
      }
      const rowKeys = Array.from(byRow.keys()).sort((a, b) => a - b);
      const rowOrder = buildRowOrder(rowKeys);
      const ordered = [];
      rowOrder.forEach((rowKey, idx) => {
        const rowSeats = byRow.get(rowKey);
        rowSeats.sort((a, b) => a.col - b.col);
        if (idx % 2 === 1) rowSeats.reverse();
        ordered.push(...rowSeats);
      });
      ordered.reverse();
      return ordered;
    };

    const buildSpreadOrder = (seats) => {
      const byRow = new Map();
      for (const seat of seats) {
        if (!byRow.has(seat.row)) byRow.set(seat.row, []);
        byRow.get(seat.row).push(seat);
      }
      const rowKeys = Array.from(byRow.keys()).sort((a, b) => a - b);
      const rowOrder = buildRowOrder(rowKeys);
      const ordered = [];
      rowOrder.forEach((rowKey) => {
        const rowSeats = byRow.get(rowKey);
        rowSeats.sort((a, b) => a.col - b.col);
        if (Math.random() < 0.5) rowSeats.reverse();
        ordered.push(...rowSeats);
      });
      ordered.reverse();
      return ordered;
    };

    const buildFrontBiasOrder = (seats) => {
      const byRow = new Map();
      for (const seat of seats) {
        if (!byRow.has(seat.row)) byRow.set(seat.row, []);
        byRow.get(seat.row).push(seat);
      }
      const rowKeys = Array.from(byRow.keys()).sort((a, b) => a - b);
      if (rowKeys.length === 0) return [];
      const frontCount = Math.max(1, Math.ceil(rowKeys.length * W_FRONT_SLICE));
      const front = rowKeys.slice(0, frontCount);
      const back = rowKeys.slice(frontCount);
      const rowOrder = [];
      while (front.length || back.length) {
        if (front.length && (back.length === 0 || Math.random() < W_FRONT_SHARE)) {
          rowOrder.push(front.shift());
        } else {
          const idx = Math.floor(Math.random() * back.length);
          rowOrder.push(back.splice(idx, 1)[0]);
        }
      }
      const ordered = [];
      rowOrder.forEach((rowKey) => {
        const rowSeats = byRow.get(rowKey);
        rowSeats.sort((a, b) => a.col - b.col);
        if (Math.random() < 0.5) rowSeats.reverse();
        ordered.push(...rowSeats);
      });
      ordered.reverse();
      return ordered;
    };

    const interleaveRows = (list, rowBias = 0) => {
      if (list.length <= 2) return list.slice();
      const popOrder = list.slice().reverse();
      const byRow = new Map();
      const rowRank = new Map();
      for (let i = 0; i < popOrder.length; i++) {
        const seat = popOrder[i];
        if (!byRow.has(seat.row)) {
          byRow.set(seat.row, []);
          rowRank.set(seat.row, i);
        }
        byRow.get(seat.row).push(seat);
      }
      for (const rowSeats of byRow.values()) {
        shuffle(rowSeats);
      }
      let activeRows = Array.from(byRow.keys());
      const maxRank = Math.max(...Array.from(rowRank.values()));
      const weightFor = (row) => {
        if (!rowBias) return 1;
        const rank = rowRank.get(row) || 0;
        const normalized = maxRank > 0 ? (1 - (rank / maxRank)) : 1;
        return (1 - rowBias) + rowBias * normalized;
      };
      const pickRow = (rows) => {
        let total = 0;
        for (const row of rows) total += weightFor(row);
        let roll = Math.random() * total;
        for (const row of rows) {
          roll -= weightFor(row);
          if (roll <= 0) return row;
        }
        return rows[rows.length - 1];
      };
      const interleaved = [];
      let lastRow = null;
      while (activeRows.length) {
        let candidates = activeRows;
        if (lastRow !== null && activeRows.length > 1) {
          candidates = activeRows.filter((row) => row !== lastRow);
        }
        const rowKey = pickRow(candidates);
        const rowSeats = byRow.get(rowKey);
        if (rowSeats && rowSeats.length) {
          interleaved.push(rowSeats.pop());
          if (!rowSeats.length) {
            activeRows = activeRows.filter((row) => row !== rowKey);
          }
        } else {
          activeRows = activeRows.filter((row) => row !== rowKey);
        }
        lastRow = rowKey;
      }
      return interleaved.reverse();
    };


    const buildOccupancy = (seatmap, loads) => {
      const seatsByClass = { F: [], C: [], W: [], Y: [] };
      const cRowCounts = [];
      seatmap.rows.forEach((row) => {
        if (!row.hasSeat) return;
        const rowClass = row.cells.find((c) => c) || "";
        if (rowClass !== "C") return;
        let count = 0;
        for (const cell of row.cells) {
          if (cell === "C") count += 1;
        }
        if (count) cRowCounts.push(count);
      });
      let isC121 = false;
      let isC222 = false;
      let isC232 = false;
      if (cRowCounts.length) {
        const freq = new Map();
        for (const count of cRowCounts) {
          freq.set(count, (freq.get(count) || 0) + 1);
        }
        let mode = null;
        let modeCount = 0;
        for (const [count, times] of freq.entries()) {
          if (times > modeCount) {
            modeCount = times;
            mode = count;
          }
        }
        isC121 = mode === 4;
        isC222 = mode === 6;
        isC232 = mode === 7;
      }
      seatmap.rows.forEach((row, rIdx) => {
        if (!row.hasSeat) return;
        const rowCells = row.cells;
        const seatCols = [];
        for (let c = 0; c < rowCells.length; c++) {
          if (rowCells[c]) seatCols.push(c);
        }
        if (!seatCols.length) return;
        const firstSeat = seatCols[0];
        const lastSeat = seatCols[seatCols.length - 1];
        const midSeat = (firstSeat + lastSeat) / 2;
        for (let idx = 0; idx < seatCols.length; idx++) {
          const c = seatCols[idx];
          const cls = rowCells[c];
          const colIndex = seatmap.baseCol + (row.offset || 0) + c + 1;
          const isEF = cls === "C" && (colIndex === 5 || colIndex === 6);
          const isE = cls === "C" && colIndex === 5;
          const isCenter = cls === "C" && isC222 && seatCols.length === 6 && (idx === 2 || idx === 3);
          const isCD = cls === "F" && (colIndex === 3 || colIndex === 4);
          const hasSeatLeft = c > firstSeat;
          const hasSeatRight = c < lastSeat;
          const leftEmpty = c > 0 && !rowCells[c - 1];
          const rightEmpty = c < rowCells.length - 1 && !rowCells[c + 1];
          let type = "middle";
          if (!hasSeatLeft || !hasSeatRight) type = "window";
          else if ((leftEmpty && hasSeatLeft) || (rightEmpty && hasSeatRight)) type = "aisle";
          const side = c <= midSeat ? "L" : "R";
          seatsByClass[cls].push({ key: `${rIdx}:${c}`, type, row: rIdx, col: c, side, isEF, isE, isCenter, isCD });
        }
      });

      const occupied = new Set();
      for (const cls of Object.keys(seatsByClass)) {
        const seats = seatsByClass[cls];
        if (!seats.length) continue;
        const grouped = { window: [], aisle: [], middle: [] };
        for (const seat of seats) grouped[seat.type].push(seat);
        let windowList = grouped.window.slice();
        let aisleList = grouped.aisle.slice();
        let middleList = grouped.middle.slice();
        let all = seats.slice();
        let efList = [];
        let eList = [];
        let centerList = [];
        if (cls === "C") {
          const orderFn = buildZigzagOrder;
          windowList = orderFn(windowList);
          aisleList = orderFn(aisleList);
          middleList = orderFn(middleList);
          all = orderFn(all);
          efList = orderFn(seats.filter((s) => s.isEF && (!isC232 || !s.isE) && (!isC222 || !s.isCenter)));
          if (isC232) {
            eList = orderFn(seats.filter((s) => s.isE));
            windowList = windowList.filter((s) => !s.isE);
            aisleList = aisleList.filter((s) => !s.isE);
            middleList = middleList.filter((s) => !s.isE);
            all = all.filter((s) => !s.isE);
          }
          if (isC222) {
            centerList = orderFn(seats.filter((s) => s.isCenter));
            windowList = windowList.filter((s) => !s.isCenter);
            aisleList = aisleList.filter((s) => !s.isCenter);
            middleList = middleList.filter((s) => !s.isCenter);
            all = all.filter((s) => !s.isCenter);
          }
        } else if (cls === "W") {
          windowList = buildFrontBiasOrder(windowList);
          aisleList = buildFrontBiasOrder(aisleList);
          middleList = buildFrontBiasOrder(middleList);
          all = buildFrontBiasOrder(all);
        } else if (cls === "F") {
          windowList = buildSpreadOrder(windowList);
          aisleList = buildSpreadOrder(aisleList);
          middleList = buildSpreadOrder(middleList);
          all = buildSpreadOrder(all);
        } else {
          shuffle(windowList);
          shuffle(aisleList);
          shuffle(middleList);
          shuffle(all);
        }

        let remaining = Math.min(loads[cls] || 0, seats.length);
        const classLoadRatio = seats.length ? (remaining / seats.length) : 0;
        const scatterLowDensity = classLoadRatio > 0 && classLoadRatio < LOW_DENSITY_SCATTER;
        if (scatterLowDensity) {
          const rowBias = cls === "W" ? 0.6 : (cls === "F" ? 0.35 : (cls === "C" ? 0.25 : 0.15));
          windowList = interleaveRows(windowList, rowBias);
          aisleList = interleaveRows(aisleList, rowBias);
          middleList = interleaveRows(middleList, rowBias);
          all = interleaveRows(all, rowBias);
          if (efList.length) efList = interleaveRows(efList, rowBias);
          if (eList.length) eList = interleaveRows(eList, rowBias);
          if (centerList.length) centerList = interleaveRows(centerList, rowBias);
        }
        let c121BiasSide = null;
        let c121BiasShare = 0;
        let windowLeft = [];
        let windowRight = [];
        let aisleLeft = [];
        let aisleRight = [];
        let allLeft = [];
        let allRight = [];
        if (cls === "C" && isC121) {
          c121BiasSide = Math.random() < 0.5 ? "L" : "R";
          c121BiasShare = classLoadRatio < 0.55 ? 0.75 : 0.6;
          windowLeft = windowList.filter((s) => s.side === "L");
          windowRight = windowList.filter((s) => s.side === "R");
          aisleLeft = aisleList.filter((s) => s.side === "L");
          aisleRight = aisleList.filter((s) => s.side === "R");
          allLeft = all.filter((s) => s.side === "L");
          allRight = all.filter((s) => s.side === "R");
        }
        const preferWindow = cls === "C"
          && isC121
          && classLoadRatio > 0
          && classLoadRatio < C121_LOW_LOAD;
        const used = new Set();
        const pairShare = cls === "F" ? 0.5 : (cls === "C" ? ADJACENT_PAIR_SHARE : 0);
        if (pairShare > 0 && remaining > 1) {
          const seatMap = new Map();
          const rowCols = new Map();
          for (const seat of seats) {
            seatMap.set(seat.key, seat);
            if (!rowCols.has(seat.row)) rowCols.set(seat.row, []);
            rowCols.get(seat.row).push(seat.col);
          }
          const pairList = [];
          for (const [rowKey, cols] of rowCols.entries()) {
            const sorted = cols.sort((a, b) => a - b);
            const eligible = [];
            for (const col of sorted) {
              const seat = seatMap.get(`${rowKey}:${col}`);
              if (!seat) continue;
              if (cls === "F" && !seat.isCD) continue;
              if (cls === "C" && isC232 && seat.isE) continue;
              eligible.push(col);
            }
            let idx = 0;
            while (idx < eligible.length - 1) {
              if (eligible[idx + 1] === eligible[idx] + 1) {
                const a = seatMap.get(`${rowKey}:${eligible[idx]}`);
                const b = seatMap.get(`${rowKey}:${eligible[idx + 1]}`);
                if (a && b) pairList.push([a, b]);
                idx += 2;
              } else {
                idx += 1;
              }
            }
          }
          const maxPairs = pairList.length;
          let pairTarget = Math.min(Math.floor(remaining * pairShare / 2), maxPairs);
          shuffle(pairList);
          for (const [a, b] of pairList) {
            if (remaining < 2 || pairTarget <= 0) break;
            if (used.has(a.key) || used.has(b.key)) continue;
            used.add(a.key);
            used.add(b.key);
            occupied.add(a.key);
            occupied.add(b.key);
            remaining -= 2;
            pairTarget -= 1;
          }
        }

        while (remaining > 0) {
          let seat = null;
          if (preferWindow && Math.random() < C121_WINDOW_SHARE) {
            if (isC121) {
              seat = pickFromSide(windowLeft, windowRight, c121BiasSide, c121BiasShare, used)
                || pickFromSide(aisleLeft, aisleRight, c121BiasSide, c121BiasShare, used)
                || pickFromList(middleList, used);
            } else {
              seat = pickFromList(windowList, used)
                || pickFromList(efList, used)
                || pickFromList(aisleList, used)
                || pickFromList(middleList, used);
            }
          } else if (Math.random() < PREF_PROB) {
            if (cls === "C") {
              const efShare = preferWindow ? C121_EF_SHARE : C_EF_SHARE;
              if (Math.random() < efShare) {
                seat = pickFromList(efList, used)
                  || (isC121 ? pickFromSide(windowLeft, windowRight, c121BiasSide, c121BiasShare, used) : pickFromList(windowList, used))
                  || (isC121 ? pickFromSide(aisleLeft, aisleRight, c121BiasSide, c121BiasShare, used) : pickFromList(aisleList, used))
                  || pickFromList(middleList, used);
              } else {
                seat = (isC121 ? pickFromSide(windowLeft, windowRight, c121BiasSide, c121BiasShare, used) : pickFromList(windowList, used))
                  || pickFromList(efList, used)
                  || (isC121 ? pickFromSide(aisleLeft, aisleRight, c121BiasSide, c121BiasShare, used) : pickFromList(aisleList, used))
                  || pickFromList(middleList, used);
              }
            } else {
              seat = pickFromList(windowList, used)
                || pickFromList(aisleList, used)
                || pickFromList(middleList, used);
            }
          }
          if (!seat && preferWindow) {
            seat = isC121
              ? pickFromSide(windowLeft, windowRight, c121BiasSide, c121BiasShare, used)
              : pickFromList(windowList, used);
          }
          if (!seat) {
            seat = isC121
              ? pickFromSide(allLeft, allRight, c121BiasSide, c121BiasShare, used)
              : pickFromList(all, used);
          }
          if (!seat && centerList.length) seat = pickFromList(centerList, used);
          if (!seat && eList.length) seat = pickFromList(eList, used);
          if (!seat) break;
          used.add(seat.key);
          occupied.add(seat.key);
          remaining -= 1;
        }
      }
      return occupied;
    };

    const renderSeatmap = () => {
      seatmapWrap.innerHTML = "";
      const seatmapKey = currentSeatmapKey || currentAircraftName || aircraftSelect.value;
      const seatmap = seatmapByKey[seatmapKey];
      if (!seatmap) {
        seatmapMeta.textContent = "Seatmap not loaded";
        return;
      }
      const countText = formatCounts(seatmap.counts);
      const label = seatmapKey || currentAircraftName || aircraftSelect.value;
      seatmapMeta.textContent = countText ? `${label} - ${countText}` : label;

      const baseName = currentAircraftName || aircraftSelect.value || "";
      const occupied = buildOccupancy(seatmap, currentLoads);
      const nameLower = baseName.toLowerCase();
      const isB777 = nameLower.includes("b777");
      const isB777FourClass = nameLower.includes("b777-300er four class");

      seatmap.rows.forEach((row, rIdx) => {
        if (!row.hasSeat) {
          const gap = document.createElement("div");
          gap.className = "seatmapRow gapRow";
          if (row.exit) gap.classList.add("exitRow");
          gap.style.setProperty("--row-cols", seatmap.maxCols || 1);
          gap.style.setProperty("--row-gap-x", `${BASE_GAP_X}px`);
          gap.style.setProperty("--row-gap-y", `${BASE_GAP_Y}px`);
          gap.style.setProperty("--row-pad-x", "0px");
          seatmapWrap.appendChild(gap);
          return;
        }
        const rowEl = document.createElement("div");
        rowEl.className = "seatmapRow";
        if (row.exit) rowEl.classList.add("exitRow");
        const rowClass = row.cells.find((c) => c) || "";
        const isB777C = isB777 && rowClass === "C" && !isB777FourClass;
        rowEl.style.setProperty("--row-cols", row.cols);
        rowEl.style.setProperty("--row-gap-x", `${isB777C ? B777_C_GAP_X : BASE_GAP_X}px`);
        rowEl.style.setProperty("--row-gap-y", `${isB777C ? B777_C_GAP_Y : BASE_GAP_Y}px`);
        const padX = isB777C ? 10 : 0;
        rowEl.style.setProperty("--row-pad-x", `${padX}px`);

        for (let c = 0; c < row.cols; c++) {
          const cls = row.cells[c];
          const cell = document.createElement("div");
          if (!cls) {
            cell.className = "seatCell space";
          } else {
            cell.className = "seatCell seat";
            cell.dataset.class = cls;
            if (occupied.has(`${rIdx}:${c}`)) cell.classList.add("occupied");
          }
          rowEl.appendChild(cell);
        }
        seatmapWrap.appendChild(rowEl);
      });
    };

    const loadSeatmapFile = async (file) => {
      if (!file || !window.XLSX) {
        seatmapMeta.textContent = "Seatmap loader unavailable";
        return;
      }
      const data = await file.arrayBuffer();
      const wb = XLSX.read(data, { type: "array" });
      parseSeatmapWorkbook(wb);
    };

        let autoSeatmapRetries = 0;

    const tryAutoLoadSeatmap = async () => {
      if (location.protocol === "file:") {
        seatmapMeta.textContent = "Run a local server to load seatmap.xlsx";
        return;
      }
      if (!window.XLSX) {
        if (autoSeatmapRetries < 5) {
          autoSeatmapRetries += 1;
          setTimeout(tryAutoLoadSeatmap, 300);
        } else {
          seatmapMeta.textContent = "Seatmap loader unavailable";
        }
        return;
      }
      if (Object.keys(seatmapByKey).length) return;
      try {
        const res = await fetch("seatmap.xlsx", { cache: "no-store" });
        if (!res.ok) {
          seatmapMeta.textContent = "Seatmap not found: seatmap.xlsx";
          return;
        }
        const data = await res.arrayBuffer();
        const wb = XLSX.read(data, { type: "array" });
        parseSeatmapWorkbook(wb);
      } catch (e) {
        seatmapMeta.textContent = "Seatmap load failed";
      }
    };

    const initAircraftSelect = (preferredName = "") => {
      aircraftSelect.innerHTML = "";
      for (const a of aircraftData) {
        const opt = document.createElement("option");
        opt.value = a.name;
        opt.textContent = a.name;
        aircraftSelect.appendChild(opt);
      }
      let idx = 0;
      if (preferredName) {
        const found = aircraftData.findIndex((a) => a.name === preferredName);
        if (found >= 0) idx = found;
      }
      aircraftSelect.selectedIndex = idx;
      renderLoad();
    };

    addPressFeedback(loadRefreshBtn);
    addPressFeedback(homeBtn);
    seatmapFile.addEventListener("change", () => {
      const file = seatmapFile.files[0];
      if (file) loadSeatmapFile(file);
      seatmapFile.value = "";
    });

    aircraftSelect.addEventListener("change", renderLoad);
    lightLoadChk.addEventListener("change", renderLoad);  // ??Ï≤¥ÌÅ¨ Î≥ÄÍ≤???Ï¶âÏãú Î∞òÏòÅ
    loadRefreshBtn.addEventListener("click", renderLoad);
    homeBtn.addEventListener("click", () => showScreen('main'));

    document.getElementById('loadBtn').addEventListener("click", () => {
      showScreen('load');
      if (aircraftSelect.options.length === 0) initAircraftSelect();
      else renderLoad();
      tryAutoLoadSeatmap();
    });

    tryAutoLoadSeatmap();
  </script>
</body>
</html>

















