<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <!-- ✅ 핀치 확대/축소 허용: maximum-scale=1 제거 -->
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes" />
  <title>DXB Gate Picker</title>

  <style>
    * { box-sizing: border-box; }

    body{
      margin:0; min-height:100vh; background:#1f9d55;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
      display:flex; align-items:center; justify-content:center; color:#fff;
    }

    .container{ width:100%; max-width:420px; padding:32px 24px 40px; text-align:center; }

    h1{ font-size:28px; margin:0 0 40px; font-weight:800; letter-spacing:.5px; }

    .result{
      font-size:92px; font-weight:400; line-height:1; letter-spacing:1px;
      display:inline-block; text-shadow:0 10px 28px rgba(0,0,0,.25);
    }

    @keyframes pop{
      0%{transform:translateY(18px) scale(.8);opacity:0}
      55%{transform:translateY(-10px) scale(1.25);opacity:1}
      80%{transform:translateY(4px) scale(.96)}
      100%{transform:translateY(0) scale(1)}
    }
    .pop{ animation:pop 460ms cubic-bezier(.2,.9,.2,1) both; }

    .btn{
      width:100%; border:none; border-radius:18px; background:#fff; cursor:pointer;
      box-shadow:0 7px 0 #148243;
      display:flex; align-items:center; justify-content:center;
      transition:transform .06s ease, box-shadow .06s ease, background-color .12s ease;
      -webkit-tap-highlight-color:transparent;
      position:relative; overflow:hidden;
    }
    .btn:active{
      transform:translateY(5px);
      box-shadow:0 2px 0 #148243;
      background-color:#e5e7eb;
    }
    .btn.pressed::after{ content:""; position:absolute; inset:0; background:rgba(0,0,0,.08); }

    #pickBtn{ margin-top:52px; height:88px; }
    #pickBtn svg{ width:46px; height:46px; stroke:#1f9d55; stroke-width:2.2; fill:none; }

    #mapBtn{
      margin-top:14px; height:62px; font-size:16px; font-weight:700;
      color:#1f9d55; letter-spacing:.2px;
    }
    #mapBtn svg{
      width:18px; height:18px; margin-right:10px; stroke:#1f9d55; stroke-width:2.2; fill:none;
    }

    /* ---------- Fullscreen viewer ---------- */
    .viewer{
      position:fixed; inset:0; background:#000; display:none; z-index:999;
      /* ✅ 핀치 줌 허용 */
      touch-action: pinch-zoom;
    }
    .viewer.show{ display:block; }

    .viewerHeader{
      position:absolute; top:0; left:0; right:0;
      padding:14px 14px 10px;
      display:flex; align-items:center; justify-content:space-between;
      z-index:3;
      background:linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,0));
    }
    .badge{
      font-size:13px; font-weight:700; color:rgba(255,255,255,.9);
      background:rgba(255,255,255,.14);
      border:1px solid rgba(255,255,255,.18);
      padding:8px 10px; border-radius:999px;
      backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
      user-select:none;
    }
    .closeX{
      border:none; background:rgba(255,255,255,.14);
      border:1px solid rgba(255,255,255,.18);
      border-radius:14px;
      width:44px; height:44px;
      display:grid; place-items:center;
      cursor:pointer;
      backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
      -webkit-tap-highlight-color:transparent;
    }
    .closeX svg{ width:22px; height:22px; stroke:#fff; stroke-width:2.4; fill:none; }

    .track{
      height:100%; width:100%;
      display:flex;
      transform:translateX(0);
      transition:transform 240ms ease;
      will-change:transform;
      /* ✅ 한 손가락 스와이프는 JS로, 두 손가락 핀치는 브라우저에 맡김 */
      touch-action: pan-y pinch-zoom;
    }

    .slide{
      min-width:100%;
      height:100%;
      display:grid;
      place-items:center;
      padding:64px 10px 18px;
      user-select:none;
    }

    .slide img{
      max-width:100%;
      max-height:calc(100vh - 90px);
      object-fit:contain;
      display:block;
      -webkit-user-drag:none;
      user-select:none;
      /* ✅ 핀치 제스처가 이미지 위에서도 동작하도록 */
      pointer-events:auto;
      touch-action: pinch-zoom;
    }

    .dots{
      position:absolute; left:0; right:0; bottom:14px;
      display:flex; justify-content:center; gap:8px;
      z-index:3; pointer-events:none;
    }
    .dot{ width:7px; height:7px; border-radius:999px; background:rgba(255,255,255,.35); }
    .dot.active{ background:rgba(255,255,255,.92); }
  </style>
</head>

<body>
  <div class="container">
    <h1>DXB Gate Picker</h1>

    <div class="result" id="result">—</div>

    <button id="pickBtn" class="btn" type="button" aria-label="Generate Gate">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M21 12a9 9 0 1 1-2.64-6.36"/>
        <polyline points="21 3 21 9 15 9"/>
      </svg>
    </button>

    <button id="mapBtn" class="btn" type="button" aria-label="View Map">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 6l6-2 6 2 6-2v14l-6 2-6-2-6 2V6z"/>
        <path d="M9 4v14M15 6v14"/>
      </svg>
      View Map
    </button>
  </div>

  <div id="viewer" class="viewer" role="dialog" aria-modal="true" aria-label="Maps">
    <div class="viewerHeader">
      <div id="badge" class="badge">1 / 2</div>
      <button id="closeViewer" class="closeX" type="button" aria-label="Close">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 6l12 12M18 6L6 18"/>
        </svg>
      </button>
    </div>

    <div id="track" class="track">
      <div class="slide"><img src="h1.png" alt="h1 map" draggable="false" /></div>
      <div class="slide"><img src="h2.png" alt="h2 map" draggable="false" /></div>
    </div>

    <div class="dots" aria-hidden="true">
      <div class="dot" id="dot0"></div>
      <div class="dot" id="dot1"></div>
    </div>
  </div>

  <script>
    /* ---------- Press feedback ---------- */
    const addPressFeedback = (btn) => {
      const on = () => btn.classList.add('pressed');
      const off = () => btn.classList.remove('pressed');
      btn.addEventListener('pointerdown', on);
      btn.addEventListener('pointerup', off);
      btn.addEventListener('pointerleave', off);
      btn.addEventListener('pointercancel', off);
    };

    /* ---------- Gate logic ---------- */
    const range = (p, s, e, ex = new Set()) => {
      const a = [];
      for (let i = s; i <= e; i++) {
        const v = `${p}${i}`;
        if (!ex.has(v)) a.push(v);
      }
      return a;
    };

    const poolA = range("A", 1, 24, new Set(["A6","A7","A18","A19"]));
    const poolB = range("B", 6, 32, new Set(["B7","B16"]));
    const poolC = [...range("C", 1, 23, new Set(["C15"])), ...range("C", 37, 46)];
    const pools = { A: poolA, B: poolB, C: poolC, Remote: ["Remote"] };

    const pickCategory = () => {
      const r = Math.random() * 100;
      if (r < 30) return "A";
      if (r < 60) return "B";
      if (r < 90) return "C";
      return "Remote";
    };
    const pickOne = (a) => a[Math.floor(Math.random() * a.length)];
    const haptic = () => { if (navigator.vibrate) navigator.vibrate([20,12,20]); };

    const resultEl = document.getElementById('result');
    const pickBtn = document.getElementById('pickBtn');
    const mapBtn  = document.getElementById('mapBtn');

    addPressFeedback(pickBtn);
    addPressFeedback(mapBtn);

    const playPop = () => {
      resultEl.classList.remove('pop');
      void resultEl.offsetWidth;
      resultEl.classList.add('pop');
    };

    pickBtn.addEventListener('click', () => {
      haptic();
      resultEl.textContent = pickOne(pools[pickCategory()]);
      playPop();
    });

    /* ---------- Viewer + swipe (핀치 줌과 공존) ---------- */
    const viewer = document.getElementById('viewer');
    const closeViewer = document.getElementById('closeViewer');
    const track = document.getElementById('track');
    const badge = document.getElementById('badge');
    const dots = [document.getElementById('dot0'), document.getElementById('dot1')];

    const slideCount = 2;
    let index = 0;

    const setIndex = (i, animate = true) => {
      index = Math.max(0, Math.min(slideCount - 1, i));
      track.style.transition = animate ? 'transform 240ms ease' : 'none';
      track.style.transform = `translateX(${-index * 100}%)`;
      badge.textContent = `${index + 1} / ${slideCount}`;
      dots.forEach((d, idx) => d.classList.toggle('active', idx === index));
    };

    const openViewer = () => {
      viewer.classList.add('show');
      document.body.style.overflow = 'hidden';
      setIndex(0, false);
    };
    const close = () => {
      viewer.classList.remove('show');
      document.body.style.overflow = '';
    };

    mapBtn.addEventListener('click', openViewer);
    closeViewer.addEventListener('click', close);

    // ✅ 두 손가락(핀치)일 때는 스와이프 로직이 개입하지 않도록 "활성 포인터 수"로 제어
    const activePointers = new Map(); // pointerId -> {x}
    let startX = 0;
    let dx = 0;
    let swiping = false;

    const vw = () => Math.max(1, window.innerWidth || 375);

    track.addEventListener('pointerdown', (e) => {
      if (!viewer.classList.contains('show')) return;
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      // 한 손가락일 때만 스와이프 시작
      if (activePointers.size === 1) {
        swiping = true;
        startX = e.clientX;
        dx = 0;
        track.style.transition = 'none';
      } else {
        // 두 손가락 이상이면 스와이프 중단(핀치 줌은 브라우저가 처리)
        swiping = false;
      }
      track.setPointerCapture(e.pointerId);
    });

    track.addEventListener('pointermove', (e) => {
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      // 두 손가락 이상이면 스와이프 로직 미동작
      if (!swiping || activePointers.size !== 1) return;

      dx = e.clientX - startX;
      const base = -index * vw();
      track.style.transform = `translateX(${base + dx}px)`;
    });

    const endSwipe = () => {
      if (!swiping) return;
      swiping = false;

      const threshold = Math.min(90, vw() * 0.22);
      if (dx > threshold) setIndex(index - 1, true);      // 2 -> 1
      else if (dx < -threshold) setIndex(index + 1, true); // 1 -> 2
      else setIndex(index, true);

      dx = 0;
    };

    const onPointerUpOrCancel = (e) => {
      if (activePointers.has(e.pointerId)) activePointers.delete(e.pointerId);

      // 마지막 손가락이 떨어질 때만 스와이프 판정
      if (activePointers.size === 0) endSwipe();

      // 한 손가락만 남으면(핀치 후) 다음 드래그부터 정상 스와이프 가능
      if (activePointers.size === 1) swiping = false;
    };

    track.addEventListener('pointerup', onPointerUpOrCancel);
    track.addEventListener('pointercancel', onPointerUpOrCancel);

    document.addEventListener('keydown', (e) => {
      if (!viewer.classList.contains('show')) return;
      if (e.key === 'Escape') close();
      if (e.key === 'ArrowLeft') setIndex(index - 1);
      if (e.key === 'ArrowRight') setIndex(index + 1);
    });

    setIndex(0, false);
  </script>
</body>
</html>
