<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>DXB Gate Picker</title>

  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: #1f9d55;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #ffffff;
    }

    .container {
      width: 100%;
      max-width: 420px;
      padding: 32px 24px 40px;
      text-align: center;
    }

    h1 {
      font-size: 28px;
      margin: 0 0 40px;
      font-weight: 800;
      letter-spacing: 0.5px;
    }

    .result {
      font-size: 92px;
      font-weight: 400;
      line-height: 1;
      letter-spacing: 1px;
      display: inline-block;
      text-shadow: 0 10px 28px rgba(0,0,0,0.25);
    }

    @keyframes pop {
      0%   { transform: translateY(18px) scale(0.8); opacity: 0; }
      55%  { transform: translateY(-10px) scale(1.25); opacity: 1; }
      80%  { transform: translateY(4px) scale(0.96); }
      100% { transform: translateY(0) scale(1); }
    }
    .pop { animation: pop 460ms cubic-bezier(.2,.9,.2,1) both; }

    .btn {
      width: 100%;
      border: none;
      border-radius: 18px;
      background: #ffffff;
      cursor: pointer;
      box-shadow: 0 7px 0 #148243;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.06s ease, box-shadow 0.06s ease, opacity 0.15s ease;
      -webkit-tap-highlight-color: transparent;
    }

    .btn:active {
      transform: translateY(5px);
      box-shadow: 0 2px 0 #148243;
    }

    #pickBtn { margin-top: 52px; height: 88px; }
    #pickBtn svg { width: 46px; height: 46px; stroke: #1f9d55; stroke-width: 2.2; fill: none; }

    #mapBtn {
      margin-top: 14px;
      height: 62px;
      font-size: 16px;
      font-weight: 700;
      color: #1f9d55;
      letter-spacing: 0.2px;
    }
    #mapBtn svg {
      width: 18px;
      height: 18px;
      margin-right: 10px;
      stroke: #1f9d55;
      stroke-width: 2.2;
      fill: none;
    }

    /* ---------- Fullscreen viewer ---------- */
    .viewer {
      position: fixed;
      inset: 0;
      background: #000;
      display: none;
      z-index: 999;
      touch-action: pan-y; /* allow vertical scroll inside image if needed */
    }
    .viewer.show { display: block; }

    .viewerHeader {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 14px 14px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      z-index: 3;
      background: linear-gradient(to bottom, rgba(0,0,0,0.55), rgba(0,0,0,0));
    }

    .badge {
      font-size: 13px;
      font-weight: 700;
      color: rgba(255,255,255,0.9);
      background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.18);
      padding: 8px 10px;
      border-radius: 999px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      user-select: none;
    }

    .closeX {
      border: none;
      background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 14px;
      width: 44px;
      height: 44px;
      display: grid;
      place-items: center;
      cursor: pointer;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      -webkit-tap-highlight-color: transparent;
    }
    .closeX:active { transform: scale(0.98); }
    .closeX svg { width: 22px; height: 22px; stroke: #fff; stroke-width: 2.4; fill: none; opacity: 0.95; }

    /* Slides track */
    .track {
      height: 100%;
      width: 100%;
      display: flex;
      transform: translateX(0);
      transition: transform 240ms ease;
      will-change: transform;
      touch-action: pan-y; /* horizontal handled by JS */
    }

    .slide {
      min-width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      padding: 64px 10px 18px; /* header 공간 */
      user-select: none;
    }

    /* Make image fit screen */
    .slide img {
      max-width: 100%;
      max-height: calc(100vh - 90px);
      width: auto;
      height: auto;
      object-fit: contain;
      display: block;
    }

    /* Dots */
    .dots {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 14px;
      display: flex;
      justify-content: center;
      gap: 8px;
      z-index: 3;
      pointer-events: none;
    }
    .dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: rgba(255,255,255,0.35);
    }
    .dot.active { background: rgba(255,255,255,0.92); }

    /* Reduce motion */
    @media (prefers-reduced-motion: reduce) {
      .track { transition: none; }
      .pop { animation: none; }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>DXB Gate Picker</h1>

    <div class="result" id="result">—</div>

    <button id="pickBtn" class="btn" type="button" aria-label="Generate Gate">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M21 12a9 9 0 1 1-2.64-6.36"/>
        <polyline points="21 3 21 9 15 9"/>
      </svg>
    </button>

    <button id="mapBtn" class="btn" type="button" aria-label="View Map">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 6l6-2 6 2 6-2v14l-6 2-6-2-6 2V6z"/>
        <path d="M9 4v14M15 6v14"/>
      </svg>
      View Map
    </button>
  </div>

  <!-- Fullscreen swipe viewer -->
  <div id="viewer" class="viewer" role="dialog" aria-modal="true" aria-label="Maps">
    <div class="viewerHeader">
      <div id="badge" class="badge">1 / 2</div>
      <button id="closeViewer" class="closeX" type="button" aria-label="Close">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 6l12 12M18 6L6 18"/>
        </svg>
      </button>
    </div>

    <div id="track" class="track">
      <!-- 같은 폴더(루트)에 h1.png, h2.png 업로드 -->
      <div class="slide"><img src="h1.png" alt="h1 map" draggable="false" /></div>
      <div class="slide"><img src="h2.png" alt="h2 map" draggable="false" /></div>
    </div>

    <div class="dots" aria-hidden="true">
      <div class="dot" id="dot0"></div>
      <div class="dot" id="dot1"></div>
    </div>
  </div>

  <script>
    /* ---------- Gate pools ---------- */
    const range = (prefix, start, end, exclude = new Set()) => {
      const arr = [];
      for (let i = start; i <= end; i++) {
        const v = `${prefix}${i}`;
        if (!exclude.has(v)) arr.push(v);
      }
      return arr;
    };

    const poolA = range("A", 1, 24, new Set(["A6", "A7", "A18", "A19"]));
    const poolB = range("B", 6, 32, new Set(["B7", "B16"]));
    const poolC = [
      ...range("C", 1, 23, new Set(["C15"])),
      ...range("C", 37, 46)
    ];
    const poolRemote = ["Remote"];

    const pools = { A: poolA, B: poolB, C: poolC, Remote: poolRemote };

    /* ---------- 확률 ---------- */
    const pickCategory = () => {
      const r = Math.random() * 100;
      if (r < 30) return "A";
      if (r < 60) return "B";
      if (r < 90) return "C";
      return "Remote";
    };

    const pickOne = (arr) => arr[Math.floor(Math.random() * arr.length)];

    /* ---------- Haptic ---------- */
    const haptic = () => { if (navigator.vibrate) navigator.vibrate([20, 12, 20]); };

    /* ---------- Pop animation ---------- */
    const resultEl = document.getElementById("result");
    const pickBtn = document.getElementById("pickBtn");

    const playPop = () => {
      resultEl.classList.remove("pop");
      void resultEl.offsetWidth;
      resultEl.classList.add("pop");
    };

    pickBtn.addEventListener("click", () => {
      haptic();
      const gate = pickOne(pools[pickCategory()]);
      resultEl.textContent = gate;
      playPop();
    });

    /* ---------- Fullscreen swipe viewer ---------- */
    const viewer = document.getElementById("viewer");
    const mapBtn = document.getElementById("mapBtn");
    const closeViewer = document.getElementById("closeViewer");
    const track = document.getElementById("track");
    const badge = document.getElementById("badge");
    const dots = [document.getElementById("dot0"), document.getElementById("dot1")];

    const slideCount = 2;
    let index = 0;

    const setIndex = (i, animate = true) => {
      index = Math.max(0, Math.min(slideCount - 1, i));
      track.style.transition = animate ? "transform 240ms ease" : "none";
      track.style.transform = `translateX(${-index * 100}%)`;
      badge.textContent = `${index + 1} / ${slideCount}`;
      dots.forEach((d, idx) => d.classList.toggle("active", idx === index));
    };

    const openViewer = () => {
      viewer.classList.add("show");
      document.body.style.overflow = "hidden";
      setIndex(0, false);
      // iOS에서 주소창 흔들림 방지용 재계산
      setTimeout(() => setIndex(index, false), 0);
    };

    const close = () => {
      viewer.classList.remove("show");
      document.body.style.overflow = "";
    };

    mapBtn.addEventListener("click", openViewer);
    closeViewer.addEventListener("click", close);

    // Tap on background (not on image) closes
    viewer.addEventListener("click", (e) => {
      if (e.target === viewer) close();
    });

    // Keyboard (desktop)
    document.addEventListener("keydown", (e) => {
      if (!viewer.classList.contains("show")) return;
      if (e.key === "Escape") close();
      if (e.key === "ArrowLeft") setIndex(index - 1);
      if (e.key === "ArrowRight") setIndex(index + 1);
    });

    // Swipe handling
    let startX = 0;
    let startY = 0;
    let dx = 0;
    let dragging = false;
    let allowSwipe = false;

    const onStart = (x, y) => {
      startX = x; startY = y;
      dx = 0;
      dragging = true;
      allowSwipe = false;
      track.style.transition = "none";
    };

    const onMove = (x, y) => {
      if (!dragging) return;
      dx = x - startX;
      const dy = y - startY;

      // Decide if horizontal swipe (avoid blocking vertical scroll)
      if (!allowSwipe) {
        if (Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)) {
          allowSwipe = true;
        } else if (Math.abs(dy) > 10 && Math.abs(dy) > Math.abs(dx)) {
          // vertical intent -> stop swiping
          dragging = false;
          track.style.transition = "transform 240ms ease";
          return;
        }
      }

      if (!allowSwipe) return;

      // Translate in px based on viewport width
      const vw = window.innerWidth || 375;
      const base = -index * vw;
      track.style.transform = `translateX(${base + dx}px)`;
    };

    const onEnd = () => {
      if (!dragging) return;
      dragging = false;

      if (!allowSwipe) {
        setIndex(index); // snap back
        return;
      }

      const threshold = Math.min(90, (window.innerWidth || 375) * 0.22);

      if (dx > threshold) setIndex(index - 1);
      else if (dx < -threshold) setIndex(index + 1);
      else setIndex(index);
    };

    // Touch events
    track.addEventListener("touchstart", (e) => {
      if (!viewer.classList.contains("show")) return;
      const t = e.touches[0];
      onStart(t.clientX, t.clientY);
    }, { passive: true });

    track.addEventListener("touchmove", (e) => {
      if (!viewer.classList.contains("show")) return;
      const t = e.touches[0];
      onMove(t.clientX, t.clientY);
    }, { passive: true });

    track.addEventListener("touchend", () => {
      if (!viewer.classList.contains("show")) return;
      onEnd();
    }, { passive: true });

    // Mouse drag (desktop)
    track.addEventListener("mousedown", (e) => {
      if (!viewer.classList.contains("show")) return;
      onStart(e.clientX, e.clientY);
    });

    window.addEventListener("mousemove", (e) => {
      if (!viewer.classList.contains("show")) return;
      onMove(e.clientX, e.clientY);
    });

    window.addEventListener("mouseup", () => {
      if (!viewer.classList.contains("show")) return;
      onEnd();
    });

    // Init dots state
    setIndex(0, false);
  </script>
</body>
</html>
